//
//    Copyright 2018 Christopher D. McMurrough
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
/***********************************************************************************************************************
* @file find_edges.cpp
* @brief finds edges using organized edge detection
*
* Simple example of locating edges in a PCD file using organized edge detection
*
* @author Christopher D. McMurrough
**********************************************************************************************************************/

#include "CloudVisualizer.h"

#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl/io/pcd_io.h>
#include <pcl/io/ply_io.h>
#include <pcl/common/time.h>
#include <pcl/features/integral_image_normal.h>
#include <pcl/features/organized_edge_detection.h>

#define NUM_COMMAND_ARGS 1

// function prototypes
void pointPickingCallback(const pcl::visualization::PointPickingEvent& event, void* cookie);
void keyboardCallback(const pcl::visualization::KeyboardEvent &event, void* viewer_void);
bool openCloud(pcl::PointCloud<pcl::PointXYZRGBA>::Ptr &cloudOut, const char* fileName);

/***********************************************************************************************************************
* @brief callback function for handling a point picking event
* @param[in] event handle generated by the visualization window
* @param[in] cookie user data passed by the event
* @author Christoper D. McMurrough
**********************************************************************************************************************/
void pointPickingCallback(const pcl::visualization::PointPickingEvent& event, void* cookie)
{
    static int pickCount = 0;
    static pcl::PointXYZRGBA lastPoint;

    pcl::PointXYZRGBA p;
    event.getPoint(p.x, p.y, p.z);

    cout << "POINT CLICKED: " << p.x << " " << p.y << " " << p.z << endl;

    // if we have picked a point previously, compute the distance
    if(pickCount % 2 == 1)
    {
        double d = std::sqrt((p.x - lastPoint.x) * (p.x - lastPoint.x) + (p.y - lastPoint.y) * (p.y - lastPoint.y) + (p.z - lastPoint.z) * (p.z - lastPoint.z));
        cout << "DISTANCE BETWEEN THE POINTS: " << d << endl;
    }

    // update the last point and pick count
    lastPoint.x = p.x;
    lastPoint.y = p.y;
    lastPoint.z = p.z;
    pickCount++;
}

/***********************************************************************************************************************
* @brief callback function for handling a keypress event
* @param[in] event handle generated by the visualization window
* @param[in] viewer_void user data passed by the event
* @author Christoper D. McMurrough
**********************************************************************************************************************/
void keyboardCallback(const pcl::visualization::KeyboardEvent &event, void* viewer_void)
{
    // handle key down events
    if(event.keyDown())
    {
        // handle any keys of interest
        switch(event.getKeyCode())
        {
        case 'a':
            cout << "KEYPRESS DETECTED: '" << event.getKeySym() << "'" << endl;
            break;
        default:
            break;
        }
    }
}

/***********************************************************************************************************************
* @brief Opens a point cloud file
*
* Opens a point cloud file in either PCD or PLY format
*
* @param[out] cloudOut pointer to opened point cloud
* @param[in] filename path and name of input file
* @return false if an error occurred while opening file
* @author Christopher D. McMurrough
**********************************************************************************************************************/
bool openCloud(pcl::PointCloud<pcl::PointXYZRGBA>::Ptr &cloudOut, const char* fileName)
{
    // convert the file name to string
    std::string fileNameStr(fileName);

    // handle various file types
    std::string fileExtension = fileNameStr.substr(fileNameStr.find_last_of(".") + 1);
    if(fileExtension.compare("pcd") == 0)
    {
        // attempt to open the file
        if(pcl::io::loadPCDFile<pcl::PointXYZRGBA>(fileNameStr, *cloudOut) == -1)
        {
            PCL_ERROR("error while attempting to read pcd file: %s \n", fileNameStr.c_str());
            return false;
        }
        else
        {
            return true;
        }
    }
    else if(fileExtension.compare("ply") == 0)
    {
        // attempt to open the file
        if(pcl::io::loadPLYFile<pcl::PointXYZRGBA>(fileNameStr, *cloudOut) == -1)
        {
            PCL_ERROR("error while attempting to read pcl file: %s \n", fileNameStr.c_str());
            return false;
        }
        else
        {
            return true;
        }
    }
    else
    {
        PCL_ERROR("error while attempting to read unsupported file: %s \n", fileNameStr.c_str());
        return false;
    }
}

/***********************************************************************************************************************
* @brief program entry point
* @param[in] argc number of command line arguments
* @param[in] argv string array of command line arguments
* @returnS return code (0 for normal termination)
* @author Christoper D. McMurrough
**********************************************************************************************************************/
int main(int argc, char** argv)
{
    // validate and parse the command line arguments
    if(argc != NUM_COMMAND_ARGS + 1)
    {
        std::printf("USAGE: %s <file_name>\n", argv[0]);
        return 0;
    }

    // parse the command line arguments
    char* fileName = argv[1];

    // create a stop watch for measuring time
    pcl::StopWatch watch;

    // initialize the cloud viewer
    CloudVisualizer CV("Rendering Window");

    // start timing the processing step
    watch.reset();

    // open the point cloud
    pcl::PointCloud<pcl::PointXYZRGBA>::Ptr cloudIn(new pcl::PointCloud<pcl::PointXYZRGBA>);
    openCloud(cloudIn, fileName);

    // compute point cloud normals
    double normalDepthChange = 0.3;
    double normalSmoothing = 20;
    pcl::PointCloud<pcl::Normal>::Ptr normals(new pcl::PointCloud<pcl::Normal>);
    pcl::IntegralImageNormalEstimation<pcl::PointXYZRGBA, pcl::Normal> ne;
    ne.setNormalEstimationMethod(ne.COVARIANCE_MATRIX);
    ne.setMaxDepthChangeFactor(normalDepthChange);
    ne.setNormalSmoothingSize(normalSmoothing);
    ne.setInputCloud(cloudIn);
    ne.compute(*normals);

    // compute the edges
    double discontinuityThreshold = 0.02;
    int maxSearchNeighbors = 50;
    pcl::PointIndices::Ptr boundaryEdges(new pcl::PointIndices);
    pcl::PointIndices::Ptr occludingEdges(new pcl::PointIndices);
    pcl::PointIndices::Ptr occludedEdges(new pcl::PointIndices);
    pcl::PointIndices::Ptr highCurvatureEdges(new pcl::PointIndices);
    pcl::PointIndices::Ptr colorEdges(new pcl::PointIndices);
    pcl::OrganizedEdgeFromRGBNormals<pcl::PointXYZRGBA, pcl::Normal, pcl::Label> oed;
    oed.setInputNormals(normals);
    oed.setInputCloud(cloudIn);
    oed.setDepthDisconThreshold(discontinuityThreshold);
    oed.setMaxSearchNeighbors(maxSearchNeighbors);
    pcl::PointCloud<pcl::Label> labels;
    std::vector<pcl::PointIndices> labelIndices;
    oed.compute(labels, labelIndices);

    // color boundary edges blue
    for(int i = 0; i < labelIndices.at(0).indices.size(); i++)
    {
        cloudIn->points.at(labelIndices.at(0).indices.at(i)).r = 0;
        cloudIn->points.at(labelIndices.at(0).indices.at(i)).g = 0;
        cloudIn->points.at(labelIndices.at(0).indices.at(i)).b = 255;
    }

    // color occluding edges green
    for(int i = 0; i < labelIndices.at(1).indices.size(); i++)
    {
        cloudIn->points.at(labelIndices.at(1).indices.at(i)).r = 0;
        cloudIn->points.at(labelIndices.at(1).indices.at(i)).g = 255;
        cloudIn->points.at(labelIndices.at(1).indices.at(i)).b = 0;
    }


    // color occluded edges red
    for(int i = 0; i < labelIndices.at(2).indices.size(); i++)
    {
        cloudIn->points.at(labelIndices.at(2).indices.at(i)).r = 255;
        cloudIn->points.at(labelIndices.at(2).indices.at(i)).g = 0;
        cloudIn->points.at(labelIndices.at(2).indices.at(i)).b = 0;
    }

    // color high curvature edges yellow
    for(int i = 0; i < labelIndices.at(3).indices.size(); i++)
    {
        cloudIn->points.at(labelIndices.at(3).indices.at(i)).r = 255;
        cloudIn->points.at(labelIndices.at(3).indices.at(i)).g = 255;
        cloudIn->points.at(labelIndices.at(3).indices.at(i)).b = 0;
    }

    // color RGB edges pink
    for(int i = 0; i < labelIndices.at(4).indices.size(); i++)
    {
        cloudIn->points.at(labelIndices.at(4).indices.at(i)).r = 255;
        cloudIn->points.at(labelIndices.at(4).indices.at(i)).g = 0;
        cloudIn->points.at(labelIndices.at(4).indices.at(i)).b = 255;
    }


    // get the elapsed time
    double elapsedTime = watch.getTimeSeconds();
    std::cout << elapsedTime << " seconds passed " << std::endl;

    // render the scene
    CV.addCloud(cloudIn);
    CV.addCoordinateFrame(cloudIn->sensor_origin_, cloudIn->sensor_orientation_);

    // register mouse and keyboard event callbacks
    CV.registerPointPickingCallback(pointPickingCallback, cloudIn);
    CV.registerKeyboardCallback(keyboardCallback);

    // enter visualization loop
    while(CV.isRunning())
    {
        CV.spin(100);
    }

    // exit program
    return 0;
}
